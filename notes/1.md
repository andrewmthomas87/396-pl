## Prehistory

- Late 50s/early 60s
- SOTA: spaghetti: following noodles, series of instructions followed by jumps
- Directly inspired by Turing machines -> inspired early computer arch (Maniac I by Von Neumann: nice book about this)
- Language of the day: Fortran, but labels & gotos & variables
- Slow iterations
- Make better by hiding low-level
- Structured programming: organization of code in blocks
  - consists
    - sequencing (p; q)
    - if statements (if e p q)
    - loops (while c p)
  - additional
    - nesting of blocks
    - maybe reuse blocks -> procedures (didn't come from start)
    - variables (abstract registers & memory manipulation): already existed
  - showed it's Turing complete using these structures (using subset of ALGOL). Don't even need fancy control flow
    - put to rest concerns of lack of power
  - paper by Djykstra: GOTO statement considered harmful
    - philosophical argument for structured programming
    - just 2 pages
    - more understandable
  - debate lasted until 90s on structured programming
    - emergence of Java put to rest debate
  - another effect: start of gathering of discussions for how programming should change
    - let's form committees
    - famous committee result: ALGOL (1964)
- ALGOL
  - features
    - blocks
    - assignments
    - procedures (one of first languages)
      - nested definitions
      - recursive procedures
    - passing arguments
      - call-by-value: assign to variable visible to procedure
      - call-by-name: compute argument when needed by procedure, replace references w/ expression
      - difference important
    - types
    - limited form of subtyping (heirarchy of types)
    - to appease others
      - labels
      - GOTO
  - assignments, procedures, call-by semantics, & types hardest things to balance: created based on melting pot, not systematic approach
  - meta-achievements
    - standardized describing syntax
      - dinstinction between publication, reference, & hardware language
        - publication: printing
        - reference: defined
        - hardware: machine consumes
      - don't have to look the same as long as correspondence exists
      - reference is kinda the source of truth
    - describe reference in BNF grammar notation
    - first to introduce features w/ semantics explanation. Not formal, but serious attempt to give meaning to PL.
- LISP
  - created by single person, based on single idea of computation
    - all computable functions: all partial recursive functions
    - painful to have base of everything as natural numbers when representing complex data
    - create expressive new domain, all computable functions on that domain
  - def
    - Math world (m-expressions)
      - Partial recursive functions
        - For some inputs not defined: corresponds to programs that don't terminate
        - Made of
          - Propositional expressions & basic predicates
            - x < y
            - x == y
            - x is prime
          - Conditionals
            - McCarthy said conditional is series of predicates & formulas: c: p1 -> e1, p2 -> e2, ...
          - McCarthy borrowed lambda calculus function notation: lambda(x, y) x < y
          - Can't define recursion w/ lambdas, so McCarthy added label: label(name, body): name visible in body
        - To support s-expressions: m-expressions analog
          - eq
          - car, cdr: leaks machine details
          - cons: combine s-expressions
          - all else remains the same
      - New domain: s-expressions
        - General recursive data structure
        - Bottom: atoms: any kind of symbol you can have (McCarthy capital letters, not limited to 1 character)
        - Combine atoms into pairs
        - Def s-expressions
          - atom
          - (e1 * e2)
            - Where e1 is s-expressions & e2 is s-expression
        - Some special atoms
          - NIL: empty list, leaks machine details like label
    - Translate to computer world using s-expressions as programs
      - e (if s-expression) -> e* (QUOTE, e)
      - e (if variable) -> e* cons -> CONS, x -> X
      - e (is application of function) -> e* (f*, e1*, e2*)
      - e (is lambda) -> e* (LAMBDA, (x*, y*), body*)
    - s-expressions interpreter (semantics): define partial recursive function that gives meaning to s-expressions
      - eval (a, p) (or interp)
        - a is program
        - p is list of pairs mapping identifiers to values (deferred substitution)
      - look at s-expression, decide how to call itself recursively
      - it's a recursive function over s-expressions, so can write itself as s-expression
  - put it all together
    - meaning of a call to prfs is the result of interp
    - meaning of a LISP program is the prfs that it represents
    - these two relate to each other: called circularity
    - very natural for functions to consume other functions: higher order programming
    - McCarthy shows eval function can be realized by hardware arch: creates abstract arch
      - list processing machine
      - talks about how these are stored
      - memory constraints, invents garbage collection
      - don't have to restrict to lists, shows recursively defined data structures can be placed in this structure (e.g., strings, flow charts, graphs)
      - gives idea we can run structured programs like ALGOL
